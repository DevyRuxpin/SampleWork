-- Oracle Database Schema for Kali Social Media Scraper
-- Version: 1.0.0
-- Description: Advanced Oracle schema with JSON support, partitioning, and performance optimizations
-- Compatible with: Oracle Database 12c+

-- Create tablespace if needed
-- CREATE TABLESPACE scraper_data
-- DATAFILE 'scraper_data.dbf' SIZE 100M AUTOEXTEND ON;

-- Schema version tracking table
CREATE TABLE schema_versions (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    version VARCHAR2(20) NOT NULL,
    applied_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    description CLOB,
    checksum VARCHAR2(64)
);

-- Insert current schema version
INSERT INTO schema_versions (version, description) VALUES ('1.0.0', 'Initial Oracle schema');

-- Platforms table
CREATE TABLE platforms (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(20) UNIQUE NOT NULL CHECK (name IN ('twitter', 'instagram', 'facebook', 'linkedin', 'tiktok')),
    display_name VARCHAR2(100) NOT NULL,
    base_url VARCHAR2(255) NOT NULL,
    api_url VARCHAR2(255),
    is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0,1)),
    rate_limit_per_minute NUMBER DEFAULT 60,
    rate_limit_per_hour NUMBER DEFAULT 1000,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Users table with advanced features
CREATE TABLE users (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    platform_id NUMBER NOT NULL,
    platform_user_id VARCHAR2(255) NOT NULL,
    username VARCHAR2(100) NOT NULL,
    display_name VARCHAR2(255),
    bio CLOB,
    profile_image_url VARCHAR2(500),
    banner_image_url VARCHAR2(500),
    verified NUMBER(1) DEFAULT 0 CHECK (verified IN (0,1)),
    followers_count NUMBER DEFAULT 0,
    following_count NUMBER DEFAULT 0,
    posts_count NUMBER DEFAULT 0,
    location VARCHAR2(255),
    website VARCHAR2(255),
    joined_date TIMESTAMP,
    last_scraped_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    metadata CLOB DEFAULT '{}', -- JSON string
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT uk_platform_user UNIQUE (platform_id, platform_user_id),
    CONSTRAINT uk_platform_username UNIQUE (platform_id, username),
    CONSTRAINT fk_users_platform FOREIGN KEY (platform_id) REFERENCES platforms(id) ON DELETE CASCADE
);

-- Posts table with JSON support
CREATE TABLE posts (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    platform_id NUMBER NOT NULL,
    platform_post_id VARCHAR2(255) NOT NULL,
    author_id NUMBER NOT NULL,
    post_type VARCHAR2(20) DEFAULT 'post' CHECK (post_type IN ('post', 'tweet', 'video', 'story', 'article', 'comment')),
    content CLOB,
    url VARCHAR2(500),
    media_urls CLOB DEFAULT '[]', -- JSON string
    hashtags CLOB DEFAULT '[]', -- JSON string
    mentions CLOB DEFAULT '[]', -- JSON string
    likes NUMBER DEFAULT 0,
    comments NUMBER DEFAULT 0,
    shares NUMBER DEFAULT 0,
    views NUMBER DEFAULT 0,
    is_verified NUMBER(1) DEFAULT 0 CHECK (is_verified IN (0,1)),
    is_retweet NUMBER(1) DEFAULT 0 CHECK (is_retweet IN (0,1)),
    is_reply NUMBER(1) DEFAULT 0 CHECK (is_reply IN (0,1)),
    parent_post_id VARCHAR2(255),
    language VARCHAR2(10),
    sentiment_score NUMBER(3,2),
    engagement_score NUMBER(5,2),
    published_at TIMESTAMP,
    scraped_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    raw_data CLOB DEFAULT '{}', -- JSON string
    metadata CLOB DEFAULT '{}', -- JSON string
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT uk_platform_post UNIQUE (platform_id, platform_post_id),
    CONSTRAINT fk_posts_platform FOREIGN KEY (platform_id) REFERENCES platforms(id) ON DELETE CASCADE,
    CONSTRAINT fk_posts_author FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Scraping sessions table
CREATE TABLE scraping_sessions (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_uuid VARCHAR2(36) NOT NULL,
    platform_id NUMBER NOT NULL,
    session_type VARCHAR2(50) NOT NULL, -- 'user', 'hashtag', 'keyword'
    target VARCHAR2(255) NOT NULL,
    status VARCHAR2(20) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'failed', 'cancelled')),
    total_posts NUMBER DEFAULT 0,
    successful_posts NUMBER DEFAULT 0,
    failed_posts NUMBER DEFAULT 0,
    start_time TIMESTAMP DEFAULT SYSTIMESTAMP,
    end_time TIMESTAMP,
    duration_seconds NUMBER,
    error_count NUMBER DEFAULT 0,
    last_error CLOB,
    metadata CLOB DEFAULT '{}', -- JSON string
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT fk_sessions_platform FOREIGN KEY (platform_id) REFERENCES platforms(id) ON DELETE CASCADE
);

-- Errors table for comprehensive error tracking
CREATE TABLE errors (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_id NUMBER,
    error_type VARCHAR2(100) NOT NULL,
    error_message CLOB NOT NULL,
    error_code VARCHAR2(50),
    stack_trace CLOB,
    context CLOB DEFAULT '{}', -- JSON string
    occurred_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT fk_errors_session FOREIGN KEY (session_id) REFERENCES scraping_sessions(id) ON DELETE CASCADE
);

-- Proxies table with health tracking
CREATE TABLE proxies (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    proxy_url VARCHAR2(255) UNIQUE NOT NULL,
    proxy_type VARCHAR2(20) DEFAULT 'http' CHECK (proxy_type IN ('http', 'https', 'socks4', 'socks5')),
    username VARCHAR2(100),
    password VARCHAR2(100),
    country VARCHAR2(2),
    city VARCHAR2(100),
    isp VARCHAR2(255),
    status VARCHAR2(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'failed', 'testing')),
    last_used_at TIMESTAMP,
    last_tested_at TIMESTAMP,
    success_count NUMBER DEFAULT 0,
    failure_count NUMBER DEFAULT 0,
    response_time_ms NUMBER,
    uptime_percentage NUMBER(5,2) DEFAULT 100.00,
    metadata CLOB DEFAULT '{}', -- JSON string
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Rate limits tracking table
CREATE TABLE rate_limits (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    platform_id NUMBER NOT NULL,
    proxy_id NUMBER,
    endpoint VARCHAR2(255) NOT NULL,
    requests_made NUMBER DEFAULT 0,
    requests_allowed NUMBER NOT NULL,
    reset_time TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT fk_rate_limits_platform FOREIGN KEY (platform_id) REFERENCES platforms(id) ON DELETE CASCADE,
    CONSTRAINT fk_rate_limits_proxy FOREIGN KEY (proxy_id) REFERENCES proxies(id) ON DELETE SET NULL
);

-- User agents table
CREATE TABLE user_agents (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_agent_string CLOB NOT NULL,
    browser VARCHAR2(50),
    version VARCHAR2(20),
    os VARCHAR2(50),
    device_type VARCHAR2(20),
    is_mobile NUMBER(1) DEFAULT 0 CHECK (is_mobile IN (0,1)),
    usage_count NUMBER DEFAULT 0,
    last_used_at TIMESTAMP,
    is_active NUMBER(1) DEFAULT 1 CHECK (is_active IN (0,1)),
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT uk_user_agent UNIQUE (user_agent_string)
);

-- Analytics and metrics table
CREATE TABLE analytics (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    date DATE NOT NULL,
    platform_id NUMBER NOT NULL,
    metric_name VARCHAR2(100) NOT NULL,
    metric_value NUMBER(15,2) NOT NULL,
    metadata CLOB DEFAULT '{}', -- JSON string
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT uk_date_platform_metric UNIQUE (date, platform_id, metric_name),
    CONSTRAINT fk_analytics_platform FOREIGN KEY (platform_id) REFERENCES platforms(id) ON DELETE CASCADE
);

-- Audit trail table
CREATE TABLE audit_log (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name VARCHAR2(100) NOT NULL,
    record_id NUMBER NOT NULL,
    action VARCHAR2(20) NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
    old_values CLOB, -- JSON string
    new_values CLOB, -- JSON string
    changed_by VARCHAR2(100),
    changed_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Create indexes for performance optimization

-- Posts table indexes
CREATE INDEX idx_posts_platform_id ON posts(platform_id);
CREATE INDEX idx_posts_author_id ON posts(author_id);
CREATE INDEX idx_posts_published_at ON posts(published_at);
CREATE INDEX idx_posts_scraped_at ON posts(scraped_at);
CREATE INDEX idx_posts_likes ON posts(likes DESC);
CREATE INDEX idx_posts_engagement_score ON posts(engagement_score DESC);
CREATE INDEX idx_posts_verified ON posts(is_verified);
CREATE INDEX idx_posts_composite_platform_date ON posts(platform_id, published_at DESC);

-- Users table indexes
CREATE INDEX idx_users_platform_id ON users(platform_id);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_verified ON users(verified);
CREATE INDEX idx_users_followers_count ON users(followers_count DESC);
CREATE INDEX idx_users_last_scraped_at ON users(last_scraped_at);

-- Scraping sessions indexes
CREATE INDEX idx_sessions_platform_id ON scraping_sessions(platform_id);
CREATE INDEX idx_sessions_status ON scraping_sessions(status);
CREATE INDEX idx_sessions_start_time ON scraping_sessions(start_time);
CREATE INDEX idx_sessions_session_uuid ON scraping_sessions(session_uuid);

-- Errors table indexes
CREATE INDEX idx_errors_session_id ON errors(session_id);
CREATE INDEX idx_errors_error_type ON errors(error_type);
CREATE INDEX idx_errors_occurred_at ON errors(occurred_at);

-- Proxies table indexes
CREATE INDEX idx_proxies_status ON proxies(status);
CREATE INDEX idx_proxies_country ON proxies(country);
CREATE INDEX idx_proxies_last_tested_at ON proxies(last_tested_at);
CREATE INDEX idx_proxies_uptime_percentage ON proxies(uptime_percentage DESC);

-- Rate limits indexes
CREATE INDEX idx_rate_limits_platform_endpoint ON rate_limits(platform_id, endpoint);
CREATE INDEX idx_rate_limits_reset_time ON rate_limits(reset_time);

-- Analytics indexes
CREATE INDEX idx_analytics_date_platform ON analytics(date, platform_id);
CREATE INDEX idx_analytics_metric_name ON analytics(metric_name);

-- Audit log indexes
CREATE INDEX idx_audit_log_table_record ON audit_log(table_name, record_id);
CREATE INDEX idx_audit_log_action ON audit_log(action);
CREATE INDEX idx_audit_log_changed_at ON audit_log(changed_at);

-- Create function-based indexes for JSON operations
CREATE INDEX idx_posts_metadata_json ON posts(JSON_VALUE(metadata, '$.source'));

-- Create triggers for automatic timestamp updates
CREATE OR REPLACE TRIGGER tr_posts_updated_at
    BEFORE UPDATE ON posts
    FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER tr_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER tr_sessions_updated_at
    BEFORE UPDATE ON scraping_sessions
    FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER tr_proxies_updated_at
    BEFORE UPDATE ON proxies
    FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER tr_rate_limits_updated_at
    BEFORE UPDATE ON rate_limits
    FOR EACH ROW
BEGIN
    :NEW.updated_at := SYSTIMESTAMP;
END;
/

-- Create audit trigger
CREATE OR REPLACE TRIGGER tr_audit_posts
    AFTER INSERT OR UPDATE OR DELETE ON posts
    FOR EACH ROW
DECLARE
    v_action VARCHAR2(20);
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    CASE
        WHEN INSERTING THEN
            v_action := 'INSERT';
            v_new_values := JSON_OBJECT(
                'id' VALUE :NEW.id,
                'platform_id' VALUE :NEW.platform_id,
                'platform_post_id' VALUE :NEW.platform_post_id,
                'author_id' VALUE :NEW.author_id,
                'content' VALUE :NEW.content
            );
        WHEN UPDATING THEN
            v_action := 'UPDATE';
            v_old_values := JSON_OBJECT(
                'id' VALUE :OLD.id,
                'platform_id' VALUE :OLD.platform_id,
                'platform_post_id' VALUE :OLD.platform_post_id,
                'author_id' VALUE :OLD.author_id,
                'content' VALUE :OLD.content
            );
            v_new_values := JSON_OBJECT(
                'id' VALUE :NEW.id,
                'platform_id' VALUE :NEW.platform_id,
                'platform_post_id' VALUE :NEW.platform_post_id,
                'author_id' VALUE :NEW.author_id,
                'content' VALUE :NEW.content
            );
        WHEN DELETING THEN
            v_action := 'DELETE';
            v_old_values := JSON_OBJECT(
                'id' VALUE :OLD.id,
                'platform_id' VALUE :OLD.platform_id,
                'platform_post_id' VALUE :OLD.platform_post_id,
                'author_id' VALUE :OLD.author_id,
                'content' VALUE :OLD.content
            );
    END CASE;
    
    INSERT INTO audit_log (table_name, record_id, action, old_values, new_values)
    VALUES ('posts', COALESCE(:NEW.id, :OLD.id), v_action, v_old_values, v_new_values);
END;
/

-- Create views for analytics
CREATE VIEW daily_platform_stats AS
SELECT 
    TRUNC(published_at) as date,
    platform_id,
    COUNT(*) as total_posts,
    COUNT(DISTINCT author_id) as unique_authors,
    SUM(likes) as total_likes,
    SUM(comments) as total_comments,
    SUM(shares) as total_shares,
    SUM(views) as total_views,
    AVG(engagement_score) as avg_engagement_score
FROM posts 
WHERE published_at IS NOT NULL
GROUP BY TRUNC(published_at), platform_id
ORDER BY date DESC, platform_id;

-- Performance monitoring view
CREATE VIEW performance_metrics AS
SELECT 
    'posts' as table_name,
    COUNT(*) as total_records,
    COUNT(CASE WHEN created_at > SYSTIMESTAMP - INTERVAL '1' DAY THEN 1 END) as last_24h,
    COUNT(CASE WHEN created_at > SYSTIMESTAMP - INTERVAL '7' DAY THEN 1 END) as last_7d
FROM posts
UNION ALL
SELECT 
    'users' as table_name,
    COUNT(*) as total_records,
    COUNT(CASE WHEN created_at > SYSTIMESTAMP - INTERVAL '1' DAY THEN 1 END) as last_24h,
    COUNT(CASE WHEN created_at > SYSTIMESTAMP - INTERVAL '7' DAY THEN 1 END) as last_7d
FROM users
UNION ALL
SELECT 
    'sessions' as table_name,
    COUNT(*) as total_records,
    COUNT(CASE WHEN created_at > SYSTIMESTAMP - INTERVAL '1' DAY THEN 1 END) as last_24h,
    COUNT(CASE WHEN created_at > SYSTIMESTAMP - INTERVAL '7' DAY THEN 1 END) as last_7d
FROM scraping_sessions;

-- Insert default platform data
INSERT INTO platforms (name, display_name, base_url, api_url, rate_limit_per_minute, rate_limit_per_hour) VALUES
('twitter', 'Twitter/X', 'https://twitter.com', 'https://api.twitter.com', 300, 300000);
INSERT INTO platforms (name, display_name, base_url, api_url, rate_limit_per_minute, rate_limit_per_hour) VALUES
('instagram', 'Instagram', 'https://www.instagram.com', 'https://www.instagram.com/api/v1', 200, 100000);
INSERT INTO platforms (name, display_name, base_url, api_url, rate_limit_per_minute, rate_limit_per_hour) VALUES
('facebook', 'Facebook', 'https://www.facebook.com', 'https://graph.facebook.com', 200, 100000);
INSERT INTO platforms (name, display_name, base_url, api_url, rate_limit_per_minute, rate_limit_per_hour) VALUES
('linkedin', 'LinkedIn', 'https://www.linkedin.com', 'https://www.linkedin.com/api', 100, 50000);
INSERT INTO platforms (name, display_name, base_url, api_url, rate_limit_per_minute, rate_limit_per_hour) VALUES
('tiktok', 'TikTok', 'https://www.tiktok.com', 'https://www.tiktok.com/api', 300, 150000);

-- Create stored procedures for common operations

-- Procedure to get platform statistics
CREATE OR REPLACE PROCEDURE GetPlatformStats(
    p_platform_name IN VARCHAR2 DEFAULT NULL,
    p_cursor OUT SYS_REFCURSOR
)
AS
BEGIN
    OPEN p_cursor FOR
        SELECT 
            p.name as platform,
            COUNT(DISTINCT u.id) as total_users,
            COUNT(po.id) as total_posts,
            SUM(po.likes) as total_likes,
            SUM(po.comments) as total_comments,
            SUM(po.shares) as total_shares,
            AVG(po.engagement_score) as avg_engagement
        FROM platforms p
        LEFT JOIN users u ON p.id = u.platform_id
        LEFT JOIN posts po ON p.id = po.platform_id
        WHERE p.name = p_platform_name OR p_platform_name IS NULL
        GROUP BY p.id, p.name;
END;
/

-- Procedure to clean old data
CREATE OR REPLACE PROCEDURE CleanOldData(
    p_days_to_keep IN NUMBER
)
AS
BEGIN
    -- Delete old posts
    DELETE FROM posts WHERE created_at < SYSTIMESTAMP - INTERVAL '1' DAY * p_days_to_keep;
    
    -- Delete old sessions
    DELETE FROM scraping_sessions WHERE created_at < SYSTIMESTAMP - INTERVAL '1' DAY * p_days_to_keep;
    
    -- Delete old errors
    DELETE FROM errors WHERE occurred_at < SYSTIMESTAMP - INTERVAL '1' DAY * p_days_to_keep;
    
    -- Delete old audit logs
    DELETE FROM audit_log WHERE changed_at < SYSTIMESTAMP - INTERVAL '1' DAY * p_days_to_keep;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Create functions for JSON operations (Oracle 12c+)

-- Function to extract JSON value
CREATE OR REPLACE FUNCTION ExtractJsonValue(
    p_json IN CLOB,
    p_path IN VARCHAR2
)
RETURN VARCHAR2
AS
    v_result VARCHAR2(4000);
BEGIN
    v_result := JSON_VALUE(p_json, p_path);
    RETURN v_result;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
/

-- Function to check if JSON contains value
CREATE OR REPLACE FUNCTION JsonContains(
    p_json IN CLOB,
    p_value IN VARCHAR2
)
RETURN NUMBER
AS
    v_result NUMBER := 0;
BEGIN
    IF INSTR(p_json, p_value) > 0 THEN
        v_result := 1;
    END IF;
    RETURN v_result;
END;
/

-- Create partitioned tables for large datasets (optional)
-- This requires Oracle Enterprise Edition with partitioning option

-- Posts table partitioned by date (example)
/*
CREATE TABLE posts_partitioned (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    platform_id NUMBER NOT NULL,
    platform_post_id VARCHAR2(255) NOT NULL,
    author_id NUMBER NOT NULL,
    post_type VARCHAR2(20) DEFAULT 'post',
    content CLOB,
    url VARCHAR2(500),
    media_urls CLOB DEFAULT '[]',
    hashtags CLOB DEFAULT '[]',
    mentions CLOB DEFAULT '[]',
    likes NUMBER DEFAULT 0,
    comments NUMBER DEFAULT 0,
    shares NUMBER DEFAULT 0,
    views NUMBER DEFAULT 0,
    is_verified NUMBER(1) DEFAULT 0,
    is_retweet NUMBER(1) DEFAULT 0,
    is_reply NUMBER(1) DEFAULT 0,
    parent_post_id VARCHAR2(255),
    language VARCHAR2(10),
    sentiment_score NUMBER(3,2),
    engagement_score NUMBER(5,2),
    published_at TIMESTAMP,
    scraped_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    raw_data CLOB DEFAULT '{}',
    metadata CLOB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT pk_posts_partitioned PRIMARY KEY (id, published_at),
    CONSTRAINT uk_posts_partitioned_platform_post UNIQUE (platform_id, platform_post_id, published_at),
    CONSTRAINT fk_posts_partitioned_platform FOREIGN KEY (platform_id) REFERENCES platforms(id) ON DELETE CASCADE,
    CONSTRAINT fk_posts_partitioned_author FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE
)
PARTITION BY RANGE (published_at) (
    PARTITION posts_2020 VALUES LESS THAN (TO_DATE('2021-01-01', 'YYYY-MM-DD')),
    PARTITION posts_2021 VALUES LESS THAN (TO_DATE('2022-01-01', 'YYYY-MM-DD')),
    PARTITION posts_2022 VALUES LESS THAN (TO_DATE('2023-01-01', 'YYYY-MM-DD')),
    PARTITION posts_2023 VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD')),
    PARTITION posts_2024 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD')),
    PARTITION posts_future VALUES LESS THAN (MAXVALUE)
);
*/

-- Create materialized views for analytics (optional)
/*
CREATE MATERIALIZED VIEW daily_platform_stats_mv
REFRESH FAST ON COMMIT
AS
SELECT 
    TRUNC(published_at) as date,
    platform_id,
    COUNT(*) as total_posts,
    COUNT(DISTINCT author_id) as unique_authors,
    SUM(likes) as total_likes,
    SUM(comments) as total_comments,
    SUM(shares) as total_shares,
    SUM(views) as total_views,
    AVG(engagement_score) as avg_engagement_score
FROM posts 
WHERE published_at IS NOT NULL
GROUP BY TRUNC(published_at), platform_id;
*/

-- Grant permissions (adjust as needed)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES TO scraper_user;
-- GRANT EXECUTE ON ALL PROCEDURES TO scraper_user;
-- GRANT SELECT ON ALL VIEWS TO scraper_user; 